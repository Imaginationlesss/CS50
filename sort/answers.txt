sort1 uses: Bubble sort algorithm

How do you know?: Took the lowest amount of time to sort the already sorted numbers "like we got lucky" and took the highest amount of time on randomized and reversed numbers, which is kinda of
                           self-explanatory when we know how bubble sort works, it swaps the numbers and pushes high numbers to the end.

sort2 uses: Merge sort algorithm

How do you know?: It showed the lowest real time used to sort the list of randomized numbers of 10,000 as well as sorting 50,000 reversed numbers and never needed the highest amount of time
                  during tests, which merge algorithm is really known for, which we also saw in the video time lapse the end of the lecture.

sort3 uses: Linear sort

How do you know?: First of all it took the highest amount of time to sort already sorted numbers of 5,000 which is the smallest and simplest test we could test algorithms with (Even tho is was already
                  sorted linear sort needs to go over it the second time), second I just figured out what the other two sorts were so I was left with the linear.
                  But if we are gonna use our knowledge of the algorithms we know that linear and bubble sort need almost the same amount of time to sort, sometimes linear is even faster
                  we can see that it took second place twice which might get us thinking that maybe it's a bubble sort but as already mentioned test 3 just made things really clear when it showed
                  that sort1 took almost 5 seconds to reverse all the numbers when sort 3 just took half of that time


test 1: s1 s5k = 0.018s rt
        s2 s5k= 0.036s rt
        s3 s5k = 0.063s rt

test 2: s1 ra10k = 0.184s rt
        s2 ra10k = 0.073s rt
        s3 ra10k = 0.122s rt

test 3: s1 re50k = 4.747s rt
        s2 re50k = 0.364s rt
        s3 re50k = 2.487s rt
sort1 uses: Bubble sorting algorithm

How do you know?: Took the lowest amount of time to sort the already sorted numbers "like we got lucky" and took the highest amount of time on randomized and reversed numbers, which is kinda of
                           self-explanatory when we know how bubble sort works, it swaps the numbers and pushes high numbers to the end.

sort2 uses: Merge sorting algorithm

How do you know?: It showed the lowest real time used to sort the list of randomized numbers of 10,000 as well as sorting 50,000 reversed numbers and never needed the highest amount of time
                  during tests, which merge algorithm is really known for, which we also saw in the video time lapse the end of the lecture.

sort3 uses: Linear sorting algorithm

How do you know?: First of all it took the highest amount of time to sort already sorted numbers of 5,000 which is the smallest and simplest test we could test algorithms, when sort 1 took the least,
                  second I just figured out what the other two sorts were so I was left with the linear.


test 1: s1 s5k = 0.018s rt
        s2 s5k= 0.036s rt
        s3 s5k = 0.063s rt

test 2: s1 ra10k = 0.184s rt
        s2 ra10k = 0.073s rt
        s3 ra10k = 0.122s rt

test 3: s1 re50k = 4.747s rt
        s2 re50k = 0.364s rt
        s3 re50k = 2.487s rt

